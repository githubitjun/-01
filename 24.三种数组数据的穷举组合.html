<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>
<script>
  let names = ["iPhone X", "iPhone XS"]
  let colors = ["黑色", "白色"]
  let storages = ["64g", "256g"]
  let combine = function (...chunks) {
    let res = []
    let helper = function (chunkIndex, prev) {
      let chunk = chunks[chunkIndex]
      let isLast = chunkIndex === chunks.length - 1
      for (let val of chunk) {
        let cur = prev.concat(val)
        if (isLast) {
          // 如果已经处理到数组的最后一项了 则把拼接的结果放入返回值中
          res.push(cur)
        } else {
          helper(chunkIndex + 1, cur)
        }
      }
    }
    // 从属性数组下标为 0 开始处理
    // 并且此时的 prev 是个空数组
    helper(0, [])
    return res
  }
  console.log(combine(names, colors, storages))
    /*
  1. 使用了递归, 递归函数两个参数,第一个参数是要一个下标,这个下标是和 要组合的数组的个数相关联,
  第二个参数是一个组合的数组
  利用判断 下标和 要组合的数组的个数 进行比较,只有当 相等之后就不用再递归,将凭接好的数组push 进空数组里

  最关键的点,在于这两个参数,一个是和 要组合数组的下标, 一个是组合的数组,就是当递归到最后面的时候 是将前面的数组的数据从
  最后面一个数组的数据开始组合
*/

</script>

</html>