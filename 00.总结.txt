技术点:
	01.使用crypto-js可以实现前端加密
	02.弹框使用的是vue-layer,然后使用install 方法注册成全局组件,可以全局调用
	03.复制粘贴使用的是clipboard.js  网址:http://www.clipboardjs.cn/
	04.上传图片时将图片转换为base64的方法使用的是
		web API 的FileReader, 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，
		使用 File 或 Blob 对象指定要读取的文件或数据。
		FileReader.readAsDataURL() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。
		FileReader.onload 处理load事件。该事件在读取操作完成时触发。
	
	05.URL.createObjectURL()的使用方法 看具体网址:https://www.cnblogs.com/PasserByOne/p/12034784.html
	06.blob 对象:
		一个 Blob对象表示一个不可变的, 原始数据的类似文件对象。Blob表示的数据不一定是一个JavaScript原生格式 blob对象本质上是js中的一个对象，里面可以储存大量的二进制编码格式的数据。
		网址:https://www.cnblogs.com/wangfajing/p/7202139.html
	
小程序中的坑
	01.textarea多行输入框,该组件是原生组件,该组件的placeholder 会发生穿透, 使用cover-view 可以覆盖在原生组件之上的文本视图
	cover-view 里面只支持 嵌套cover-view,cover-image,还可以使用button.
	02.使用catchtouchmove='ture' 可以阻止遮罩层下面的页面滚动
	
vue 相关
	01.Vue.observable 的使用可以实现一个简单一点的数据状态管理
	02.vue 中的依赖注入 所提供的的属性并不是响应式的
	03.vue 打包的时候多个css 文件会打包在一起,所以给不同的添加不同的前缀,然后通过后台的接口返回来实现
	04.vue 不能检测一下数组的变动
		1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue
		2.当你修改数组的长度时，例如：vm.items.length = newLength
	05.在vue 3.0 构建的项目里面要关闭eslint 使用的方式是如下代码:
		module.exports = {
		  /**
		   * 关闭eslint
		   */
		  lintOnSave: false,
		  devServer: {
			overlay: {
			  warning: false,
			  errors: false
			}
		  }
		};
	
	
重要的css 
	01.box-orient 属性规定框的子元素应该被水平或垂直排列。
		-webkit-box-orient: vertical;
		-webkit-line-clamp: 2; //显示两行文字
	02.文字内容超出 显示省略号
		overflow: hidden;
		text-overflow: ellipsis; // 当文本溢出时显示省略号
		white-space: nowrap; //强制一行显示 不换行
	03.letter-spacing 属性增加或减少字符间的空白（字符间距）。
		letter-spacing:2px
	04.white-space: nowrap 规定段落中的文本不进行换行：
		normal	默认。空白会被浏览器忽略。
		pre	空白会被浏览器保留。其行为方式类似 HTML 中的 <pre> 标签。
		nowrap	文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。
		pre-wrap	保留空白符序列，但是正常地进行换行。
		pre-line	合并空白符序列，但是保留换行符。
		inherit	规定应该从父元素继承 white-space 属性的值。

js相关
	01.js最大的安全数值是 2的53次方即是 9007199254740992;这个值是16位; 不包括两端,所以准确的是说最大的值是 2的53次方 -1; 
		在axios 中使用 处理大数据即是数字超过了安全值得方法是使用 JSONbig.parse(json) 网址:https://blog.csdn.net/weixin_44867717/article/details/104326988
	02.js是一门单线程语言,js 是实现对dom 的操作如果是多线程对dom 操作就会产生冲突,所以只能是单线程 --个人理解
	03.js的浮点数加减乘除存在精度丢失的问题,是因为会十进制转换成二进制,在使用浮点数进行大小比较的时候不要直接比较,而是要使用parseFloat()转换一下,可能两者中会有字符串则会比较失误
		比如说这种比较 "99.00"> "   99.565" 返回的就是true ---- 解决方式 parseFloat("90.00")>parseFloat("  99.565") 返回的就是false
	04.js 中使用toFixed 方法即是Number.prototype.toFixed() 可以实现四舍五入保留两位小数 比如var numObj = 12345.6789;  numObj.toFixed(2)--得到的是"12345.68"; 而且得到的是一个字符串
	05.js 中使用 instanceof--运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链;---- 可以判断数据类型;通过字面量创建的字符串是无法使用instanceof来判断某个变量是
		否是字符串,必须是通过 new 的方式才能判断; 但是对于复杂数据类型,对象和数组,不管哪种方式创建都可以使用 instanceof 来判断数据类型
	06.当访问一个对象中不确定的是否有的属性时,会报错,但是使用 ?. 就会返回undefined,不会报错,对象函数同理使用  比如console.log(flower.species?.lily) // 输出 undefined 
	07.globalThis 全局对象 JavaScript 可以在不同环境中运行，比如浏览器或者 Node.js。浏览器中可用的全局对象是变量 window，但在 Node.js 中是一个叫做 global 的对象。
		为了在不同环境中都使用统一的全局对象，引入了 globalThis 。
		// 浏览器
		window == globalThis // true
		// node.js
		global == globalThis // true
	08.使用<input type="file" name="file" @change="setFile" /> 上传图片时,如果第二次选择的是和前一张一模一样的照片时,change 事件不会触发,
		这个时候就要使用 e.srcElement.value = ""//及时清空 就可以解决
		
严格模式的主要限制
		变量必须声明后再使用
		函数的参数不能有同名属性，否则报错
		不能使用with语句
		不能对只读属性赋值，否则报错
		不能使用前缀 0 表示八进制数，否则报错
		不能删除不可删除的属性，否则报错
		不能删除变量delete prop，会报错，只能删除属性delete global[prop]
		eval不会在它的外层作用域引入变量
		eval和arguments不能被重新赋值
		arguments不会自动反映函数参数的变化
		不能使用arguments.callee  ---指的是当前函数本身,可以递归调用  但是已经废弃,不要使用
		不能使用arguments.caller	---当一个函数被另外一个函数调用时, 这个则是指向的调用这个函数的函数,就是调用者  但是已经废弃,不要使用
		禁止this指向全局对象
		不能使用fn.caller和fn.arguments获取函数调用的堆栈
		增加了保留字（比如protected、static和interface）
	
es6相关
	01.es6模块和 commonJS 模块的差异
		有两个重大的差异
			CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用  输出值得时候会被缓存,可以输出的时候携程一个取值得器函数
						
			CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
	02.Class 语法
		1.class 类不存在变量提升
		2.class 的静态方法 加上static关键字,该方法不会被实例继承,而是通过类直接调用
		3.class 的私有属性和私有方法, 是只能在类的内部访问的属性和方法,外部不能访问
				私有属性在属性之前加#号  私有方法在方法名之前加#号
	03. new.target 属性 : ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。
						如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。
		1.Class 内部调用new.target，返回当前 Class。
		2.需要注意的是，子类继承父类时，new.target会返回子类。
	04.Promise.allSettled  等待多个promise 返回结果时,我们可以使用promise.all 方法, 但是其中的一个请求失败了就会抛出错误,然而有时候我们希望某个请求失败后
		其他请求的结果能够正常返回. 我们就可以使用Promise.allSettled. 成功的 promise 将返回一个包含 status 和 value 的对象，失败的 promise 将返回一个包含 status 和 reason 的对象。

